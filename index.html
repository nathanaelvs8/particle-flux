<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stardust.el â€” Gesture-Controlled 3D Particles</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Pacifico&family=Space+Mono:wght@400;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --primary: #a855f7;
  --primary-light: #c084fc;
  --primary-dark: #7c3aed;
  --primary-glow: rgba(168, 85, 247, 0.4);
  --accent: #e879f9;
  --surface: rgba(255, 255, 255, 0.06);
  --surface-hover: rgba(255, 255, 255, 0.1);
  --surface-active: rgba(168, 85, 247, 0.15);
  --border: rgba(255, 255, 255, 0.08);
  --border-light: rgba(255, 255, 255, 0.12);
  --text: #f1f0f5;
  --text-muted: rgba(241, 240, 245, 0.5);
  --text-dim: rgba(241, 240, 245, 0.3);
  --glass-bg: rgba(15, 10, 25, 0.55);
  --glass-blur: 20px;
  --radius: 16px;
  --radius-sm: 10px;
  --radius-xs: 6px;
}

body {
  background: #0a0612;
  color: var(--text);
  font-family: 'Outfit', sans-serif;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
  cursor: default;
  user-select: none;
}

#canvas-container {
  position: fixed;
  inset: 0;
  z-index: 0;
}

canvas#three-canvas {
  display: block;
  width: 100%;
  height: 100%;
}

/* â”€â”€â”€ Glass Panel Base â”€â”€â”€ */
.glass {
  background: var(--glass-bg);
  backdrop-filter: blur(var(--glass-blur));
  -webkit-backdrop-filter: blur(var(--glass-blur));
  border: 1px solid var(--border);
  border-radius: var(--radius);
}

/* â”€â”€â”€ Side Panel â”€â”€â”€ */
#side-panel {
  position: fixed;
  top: 20px;
  left: 20px;
  bottom: 20px;
  width: 300px;
  z-index: 100;
  padding: 28px 22px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  overflow-y: auto;
  scrollbar-width: none;
  transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.4s ease;
}

/* Hide UI during calibration */
body.calibrating #side-panel,
body.calibrating #top-controls,
body.calibrating #mobile-panel-toggle,
body.calibrating #webcam-container {
  opacity: 0;
  pointer-events: none;
}

#side-panel::-webkit-scrollbar { display: none; }

#side-panel.hidden {
  transform: translateX(-340px);
  opacity: 0;
  pointer-events: none;
}

.panel-header {
  display: flex;
  align-items: center;
  gap: 10px;
  padding-bottom: 6px;
}

.panel-logo {
  width: 36px;
  height: 36px;
  border-radius: 10px;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  box-shadow: 0 4px 20px var(--primary-glow);
}

.panel-title {
  font-weight: 600;
  font-size: 20px;
  letter-spacing: -0.3px;
  background: linear-gradient(135deg, #fff 40%, var(--primary-light));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.panel-subtitle {
  font-size: 11px;
  color: var(--text-muted);
  letter-spacing: 2px;
  text-transform: uppercase;
  font-family: 'Space Mono', monospace;
}

/* â”€â”€â”€ Section â”€â”€â”€ */
.section {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.section-label {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 2.5px;
  text-transform: uppercase;
  color: var(--text-dim);
  font-family: 'Space Mono', monospace;
  padding-left: 2px;
}

/* â”€â”€â”€ Pattern Grid â”€â”€â”€ */
.pattern-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.pattern-btn {
  background: var(--surface);
  border: 1.5px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 10px;
  color: var(--text);
  cursor: pointer;
  transition: all 0.25s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  font-family: 'Outfit', sans-serif;
}

.pattern-btn:hover {
  background: var(--surface-hover);
  border-color: var(--border-light);
  transform: translateY(-1px);
}

.pattern-btn.active {
  background: var(--surface-active);
  border-color: var(--primary);
  box-shadow: 0 0 20px rgba(168, 85, 247, 0.15), inset 0 0 20px rgba(168, 85, 247, 0.05);
}

.pattern-icon {
  font-size: 24px;
  line-height: 1;
}

.pattern-name {
  font-size: 11.5px;
  font-weight: 500;
  letter-spacing: 0.3px;
}

/* â”€â”€â”€ Color Picker â”€â”€â”€ */
.color-section {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.color-presets {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.color-swatch {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  border: 2.5px solid transparent;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
}

.color-swatch:hover {
  transform: scale(1.15);
}

.color-swatch.active {
  border-color: #fff;
  box-shadow: 0 0 16px var(--primary-glow);
}

.color-custom-row {
  display: flex;
  align-items: center;
  gap: 10px;
}

.color-input-wrap {
  position: relative;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  overflow: hidden;
  border: 2px solid var(--border-light);
  flex-shrink: 0;
}

.color-input-wrap input[type="color"] {
  position: absolute;
  inset: -8px;
  width: 52px;
  height: 52px;
  border: none;
  cursor: pointer;
  background: none;
}

.color-hex {
  font-family: 'Space Mono', monospace;
  font-size: 12px;
  color: var(--text-muted);
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-xs);
  padding: 6px 10px;
  flex: 1;
  outline: none;
  transition: border-color 0.2s;
}

.color-hex:focus {
  border-color: var(--primary);
}

/* â”€â”€â”€ Particle Count Slider â”€â”€â”€ */
.slider-row {
  display: flex;
  align-items: center;
  gap: 12px;
}

.slider-row input[type="range"] {
  flex: 1;
  -webkit-appearance: none;
  height: 4px;
  border-radius: 2px;
  background: linear-gradient(90deg, var(--primary-dark), var(--primary-light));
  outline: none;
}

.slider-row input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #fff;
  box-shadow: 0 0 10px var(--primary-glow);
  cursor: pointer;
}

.slider-value {
  font-family: 'Space Mono', monospace;
  font-size: 12px;
  color: var(--primary-light);
  min-width: 40px;
  text-align: right;
}

/* â”€â”€â”€ Webcam Feed â”€â”€â”€ */
#webcam-container {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 100;
  width: 220px;
  border-radius: var(--radius);
  overflow: hidden;
  border: 1.5px solid var(--border);
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  transition: all 0.3s ease;
}

#webcam-container:hover {
  border-color: var(--primary);
  box-shadow: 0 8px 32px rgba(168, 85, 247, 0.2);
}

#webcam-container.tracking .webcam-status-dot {
  background: #22c55e;
  box-shadow: 0 0 8px rgba(34, 197, 94, 0.6);
}

.webcam-header {
  background: var(--glass-bg);
  backdrop-filter: blur(10px);
  padding: 8px 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--border);
}

.webcam-label {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--text-muted);
  font-family: 'Space Mono', monospace;
  display: flex;
  align-items: center;
  gap: 6px;
}

.webcam-status-dot {
  width: 7px;
  height: 7px;
  border-radius: 50%;
  background: #ef4444;
  box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
  transition: all 0.3s ease;
}

.webcam-gesture-label {
  font-size: 10px;
  font-family: 'Space Mono', monospace;
  color: var(--primary-light);
}

#webcam-video {
  width: 100%;
  display: block;
  transform: scaleX(-1);
  background: #000;
  aspect-ratio: 4/3;
  object-fit: cover;
}

#hand-canvas {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: calc(100% - 34px);
  transform: scaleX(-1);
  pointer-events: none;
}

/* â”€â”€â”€ Top Right Controls â”€â”€â”€ */
#top-controls {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 100;
  display: flex;
  gap: 8px;
}

.ctrl-btn {
  width: 42px;
  height: 42px;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: var(--glass-bg);
  backdrop-filter: blur(var(--glass-blur));
  color: var(--text-muted);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  transition: all 0.25s ease;
}

.ctrl-btn:hover {
  background: var(--surface-hover);
  color: var(--text);
  border-color: var(--border-light);
}

.ctrl-btn.active {
  color: var(--primary-light);
  border-color: var(--primary);
  background: var(--surface-active);
}



/* â”€â”€â”€ Info Toast â”€â”€â”€ */
#info-toast {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%) translateY(80px);
  z-index: 200;
  padding: 12px 24px;
  font-size: 13px;
  font-weight: 500;
  color: var(--text);
  border-radius: 50px;
  opacity: 0;
  transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
  pointer-events: none;
  white-space: nowrap;
}

#info-toast.show {
  transform: translateX(-50%) translateY(0);
  opacity: 1;
}

/* â”€â”€â”€ Loading Overlay â”€â”€â”€ */
#loading-overlay {
  position: fixed;
  inset: 0;
  z-index: 999;
  background: #0a0612;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 24px;
  transition: opacity 0.6s ease;
}

#loading-overlay.fade-out {
  opacity: 0;
  pointer-events: none;
}

.loader-ring {
  width: 48px;
  height: 48px;
  border: 3px solid var(--border);
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin { to { transform: rotate(360deg); } }

.loader-text {
  font-size: 13px;
  color: var(--text-muted);
  letter-spacing: 3px;
  text-transform: uppercase;
  font-family: 'Space Mono', monospace;
}

/* â”€â”€â”€ Calibration Overlay â”€â”€â”€ */
#calibration-overlay {
  position: fixed;
  inset: 0;
  z-index: 500;
  background: rgba(10, 6, 18, 0.92);
  backdrop-filter: blur(30px);
  -webkit-backdrop-filter: blur(30px);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 28px;
  transition: opacity 0.6s ease;
}

#calibration-overlay.hidden {
  opacity: 0;
  pointer-events: none;
}

/* Camera permission screen */
#cam-permission-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 24px;
  animation: fadeInUp 0.5s ease;
}

#cam-permission-screen.hidden { display: none; }

.cam-perm-icon {
  width: 80px;
  height: 80px;
  border-radius: 24px;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 36px;
  box-shadow: 0 8px 40px var(--primary-glow);
  animation: pulse-glow 2s ease-in-out infinite;
}

@keyframes pulse-glow {
  0%, 100% { box-shadow: 0 8px 40px var(--primary-glow); }
  50% { box-shadow: 0 8px 60px rgba(168, 85, 247, 0.6); }
}

.cam-perm-title {
  font-size: 24px;
  font-weight: 600;
  text-align: center;
  background: linear-gradient(135deg, #fff 40%, var(--primary-light));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.cam-perm-desc {
  font-size: 13px;
  color: var(--text-muted);
  text-align: center;
  max-width: 300px;
  line-height: 1.6;
}

.cam-perm-btn {
  background: linear-gradient(135deg, var(--primary-dark), var(--primary));
  border: none;
  color: #fff;
  padding: 14px 32px;
  border-radius: 50px;
  font-size: 15px;
  font-weight: 600;
  font-family: 'Outfit', sans-serif;
  cursor: pointer;
  transition: all 0.25s ease;
  box-shadow: 0 4px 20px var(--primary-glow);
}

.cam-perm-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 28px var(--primary-glow);
}

/* Fist calibration screen */
#fist-calibration-screen {
  display: none;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  animation: fadeInUp 0.5s ease;
}

#fist-calibration-screen.active { display: flex; }

.calib-cam-preview {
  position: relative;
  width: 280px;
  height: 210px;
  border-radius: var(--radius);
  overflow: hidden;
  border: 2px solid var(--border-light);
  box-shadow: 0 8px 40px rgba(0,0,0,0.5);
}

.calib-cam-preview video {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transform: scaleX(-1);
}

.calib-cam-preview canvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  transform: scaleX(-1);
  pointer-events: none;
}

/* Fist outline SVG overlay */
.fist-guide-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  transition: opacity 0.4s ease;
}

.fist-guide-overlay.detected {
  opacity: 0;
}

.fist-guide-svg {
  width: 120px;
  height: 140px;
  opacity: 0.6;
  animation: fist-pulse 2s ease-in-out infinite;
}

@keyframes fist-pulse {
  0%, 100% { opacity: 0.4; transform: scale(1); }
  50% { opacity: 0.7; transform: scale(1.04); }
}

.calib-title {
  font-size: 20px;
  font-weight: 600;
  text-align: center;
  color: var(--text);
}

.calib-subtitle {
  font-size: 12px;
  color: var(--text-muted);
  text-align: center;
  max-width: 280px;
  line-height: 1.5;
}

.calib-status {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  font-family: 'Space Mono', monospace;
  color: var(--text-dim);
  letter-spacing: 1px;
  text-transform: uppercase;
}

.calib-status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--text-dim);
  transition: all 0.3s ease;
}

.calib-status.detecting .calib-status-dot {
  background: #facc15;
  box-shadow: 0 0 10px rgba(250, 204, 21, 0.5);
}

.calib-status.ready .calib-status-dot {
  background: #22c55e;
  box-shadow: 0 0 10px rgba(34, 197, 94, 0.6);
}

.calib-progress-ring {
  width: 200px;
  height: 200px;
  position: absolute;
  inset: 0;
  margin: auto;
  pointer-events: none;
}

.calib-progress-ring circle {
  fill: none;
  stroke-width: 3;
  stroke-linecap: round;
  transform: rotate(-90deg);
  transform-origin: center;
}

.calib-progress-ring .bg { stroke: rgba(255,255,255,0.08); }
.calib-progress-ring .fg { 
  stroke: var(--primary); 
  stroke-dasharray: 565.48;
  stroke-dashoffset: 565.48;
  transition: stroke-dashoffset 0.1s linear;
  filter: drop-shadow(0 0 6px var(--primary-glow));
}

@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* â”€â”€â”€ Tutorial Popup â”€â”€â”€ */
#tutorial-popup {
  position: fixed;
  inset: 0;
  z-index: 600;
  background: rgba(10, 6, 18, 0.85);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.4s ease;
}

#tutorial-popup.visible {
  opacity: 1;
  pointer-events: auto;
}

.tutorial-card {
  background: rgba(20, 14, 35, 0.9);
  border: 1px solid var(--border-light);
  border-radius: 24px;
  padding: 36px 32px 28px;
  width: 420px;
  max-width: calc(100vw - 32px);
  display: flex;
  flex-direction: column;
  gap: 28px;
  animation: tutorialIn 0.5s cubic-bezier(0.22, 1, 0.36, 1);
  box-shadow: 0 20px 80px rgba(0,0,0,0.5), 0 0 60px rgba(168, 85, 247, 0.08);
}

@keyframes tutorialIn {
  from { opacity: 0; transform: scale(0.92) translateY(20px); }
  to { opacity: 1; transform: scale(1) translateY(0); }
}

.tutorial-header {
  text-align: center;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.tutorial-title {
  font-size: 22px;
  font-weight: 700;
  background: linear-gradient(135deg, #fff 30%, var(--primary-light));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.tutorial-subtitle {
  font-size: 12px;
  color: var(--text-dim);
  letter-spacing: 1px;
}

/* Gesture demo cards */
.tutorial-gestures {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.gesture-demo-card {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 16px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  transition: all 0.3s ease;
}

.gesture-demo-card:hover {
  background: var(--surface-hover);
  border-color: var(--border-light);
}

/* Hand illustration container */
.gesture-hand-visual {
  width: 72px;
  height: 72px;
  border-radius: 16px;
  background: linear-gradient(135deg, rgba(168, 85, 247, 0.12), rgba(232, 121, 249, 0.08));
  border: 1px solid rgba(168, 85, 247, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  position: relative;
  overflow: hidden;
}

.gesture-hand-visual svg {
  width: 52px;
  height: 52px;
}

/* Arrow between states */
.gesture-arrow {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.gesture-arrow svg {
  width: 24px;
  height: 24px;
  opacity: 0.4;
}

/* Particle preview mini illustration */
.gesture-result-visual {
  width: 72px;
  height: 72px;
  border-radius: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  position: relative;
  overflow: hidden;
}

.gesture-result-visual.compact {
  background: radial-gradient(circle at center, rgba(168,85,247,0.3) 0%, rgba(168,85,247,0.05) 50%, transparent 70%);
}

.gesture-result-visual.dispersed {
  background: radial-gradient(circle at center, transparent 10%, rgba(168,85,247,0.05) 30%, rgba(168,85,247,0.12) 70%);
}

/* Dots for particle preview */
.particle-dots {
  position: absolute;
  inset: 0;
}

.particle-dots span {
  position: absolute;
  width: 3px;
  height: 3px;
  border-radius: 50%;
  background: var(--primary-light);
}

.gesture-demo-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-width: 0;
}

.gesture-demo-label {
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
  display: flex;
  align-items: center;
  gap: 8px;
}

.gesture-demo-tag {
  font-size: 9px;
  font-family: 'Space Mono', monospace;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  padding: 2px 8px;
  border-radius: 20px;
  background: rgba(168, 85, 247, 0.15);
  color: var(--primary-light);
}

.gesture-demo-desc {
  font-size: 12px;
  color: var(--text-muted);
  line-height: 1.5;
}

/* Visual flow row â€” hand â†’ arrow â†’ result */
.gesture-visual-flow {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
}

.tutorial-btn {
  background: linear-gradient(135deg, var(--primary-dark), var(--primary));
  border: none;
  color: #fff;
  padding: 14px 24px;
  border-radius: 50px;
  font-size: 15px;
  font-weight: 600;
  font-family: 'Outfit', sans-serif;
  cursor: pointer;
  transition: all 0.25s ease;
  text-align: center;
  box-shadow: 0 4px 20px var(--primary-glow);
  width: 100%;
}

.tutorial-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 28px var(--primary-glow);
}

.tutorial-tip {
  text-align: center;
  font-size: 11px;
  color: var(--text-dim);
  line-height: 1.5;
}

/* â”€â”€â”€ Old Onboarding (removed, keeping hidden class for compat) â”€â”€â”€ */
#onboarding { display: none; }
#onboarding.hidden { display: none; }

/* â”€â”€â”€ Scrollbar (hidden) â”€â”€â”€ */
::-webkit-scrollbar { display: none; }

/* â”€â”€â”€ Mobile Panel Toggle â”€â”€â”€ */
#mobile-panel-toggle {
  display: none;
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 101;
  padding: 10px 20px;
  font-size: 12px;
  font-weight: 600;
  font-family: 'Outfit', sans-serif;
  color: var(--text);
  border: 1px solid var(--border-light);
  border-radius: 50px;
  cursor: pointer;
  background: var(--glass-bg);
  backdrop-filter: blur(var(--glass-blur));
}

/* â”€â”€â”€ Responsive â”€â”€â”€ */
@media (max-width: 768px) {
  #side-panel {
    width: 100%;
    left: 0;
    top: auto;
    bottom: 0;
    max-height: 55vh;
    border-radius: var(--radius) var(--radius) 0 0;
    padding: 20px 16px;
    padding-bottom: 80px;
    transform: translateY(0);
    transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
  }
  #side-panel.hidden {
    transform: translateY(100%);
    opacity: 1;
  }
  .pattern-grid {
    grid-template-columns: repeat(3, 1fr);
  }
  .pattern-btn {
    padding: 10px 6px;
  }
  .pattern-icon {
    font-size: 20px;
  }
  .pattern-name {
    font-size: 10px;
  }
  #webcam-container {
    width: 140px;
    bottom: auto;
    top: 70px;
    right: 12px;
  }
  #top-controls {
    top: 12px;
    right: 12px;
    gap: 6px;
  }
  .ctrl-btn {
    width: 38px;
    height: 38px;
    font-size: 16px;
    border-radius: 10px;
  }
  #mobile-panel-toggle {
    display: block;
  }
  #btn-toggle-panel {
    display: none;
  }
}
</style>
</head>
<body class="calibrating">

<!-- Loading -->
<div id="loading-overlay">
  <div class="loader-ring"></div>
  <div class="loader-text">Initializing</div>
</div>

<!-- Calibration Overlay -->
<div id="calibration-overlay">
  <!-- Step 1: Camera Permission -->
  <div id="cam-permission-screen">
    <div class="cam-perm-icon">ğŸ“·</div>
    <div class="cam-perm-title">Welcome to Stardust.el</div>
    <div class="cam-perm-desc">This experience uses your camera to track hand gestures. Allow camera access to begin.</div>
    <button class="cam-perm-btn" id="btn-allow-cam">Enable Camera âœ¦</button>
  </div>

  <!-- Step 2: Fist Calibration -->
  <div id="fist-calibration-screen">
    <div class="calib-title">Make a Fist âœŠ</div>
    <div class="calib-subtitle">Close your hand into a fist in front of the camera to start the experience</div>
    <div class="calib-cam-preview">
      <video id="calib-video" autoplay playsinline muted></video>
      <canvas id="calib-hand-canvas"></canvas>
      <!-- Fist guide outline -->
      <div class="fist-guide-overlay" id="fist-guide">
        <svg class="fist-guide-svg" viewBox="0 0 120 140" fill="none" xmlns="http://www.w3.org/2000/svg">
          <!-- Fist silhouette with dotted stroke -->
          <path d="M30 95 C30 95 25 80 25 65 C25 55 30 50 37 50 C37 45 40 38 47 38 C47 33 52 27 60 27 C68 27 73 33 73 38 C80 38 83 45 83 50 C90 50 95 55 95 65 C95 80 90 95 90 95 C88 108 82 120 60 120 C38 120 32 108 30 95Z"
            stroke="rgba(168, 85, 247, 0.8)" 
            stroke-width="2" 
            stroke-dasharray="6 4"
            fill="rgba(168, 85, 247, 0.05)"
          />
          <!-- Finger fold lines -->
          <path d="M38 55 C45 52 55 51 62 52" stroke="rgba(168, 85, 247, 0.4)" stroke-width="1.5" stroke-dasharray="3 3"/>
          <path d="M62 52 C70 52 78 53 83 55" stroke="rgba(168, 85, 247, 0.4)" stroke-width="1.5" stroke-dasharray="3 3"/>
          <path d="M35 70 C45 67 75 67 85 70" stroke="rgba(168, 85, 247, 0.3)" stroke-width="1" stroke-dasharray="3 3"/>
          <!-- Thumb tuck line -->
          <path d="M30 75 C32 68 35 60 37 55" stroke="rgba(168, 85, 247, 0.4)" stroke-width="1.5" stroke-dasharray="3 3"/>
        </svg>
      </div>
      <!-- Progress ring -->
      <svg class="calib-progress-ring" viewBox="0 0 200 200" id="calib-ring">
        <circle class="bg" cx="100" cy="100" r="90"/>
        <circle class="fg" cx="100" cy="100" r="90" id="calib-ring-fg"/>
      </svg>
    </div>
    <div class="calib-status" id="calib-status">
      <span class="calib-status-dot"></span>
      <span id="calib-status-text">Waiting for hand...</span>
    </div>
  </div>
</div>

<!-- Tutorial Popup -->
<div id="tutorial-popup">
  <div class="tutorial-card">
    <div class="tutorial-header">
      <div class="tutorial-title">How to Control âœ¦</div>
      <div class="tutorial-subtitle">Use hand gestures to interact with the particles</div>
    </div>
    
    <div class="tutorial-gestures">
      <!-- Fist gesture -->
      <div class="gesture-demo-card">
        <div class="gesture-visual-flow">
          <div class="gesture-hand-visual">
            <svg viewBox="0 0 52 52" fill="none">
              <rect x="12" y="14" width="28" height="24" rx="10" 
                stroke="rgba(168,85,247,0.9)" stroke-width="1.8" fill="rgba(168,85,247,0.08)"/>
              <path d="M16 18 C20 15 32 15 36 18" stroke="rgba(168,85,247,0.5)" stroke-width="1.2" stroke-linecap="round"/>
              <path d="M15 24 C22 22 30 22 37 24" stroke="rgba(168,85,247,0.35)" stroke-width="1" stroke-dasharray="2 2"/>
              <path d="M14 30 C12 26 12 20 15 17" stroke="rgba(168,85,247,0.7)" stroke-width="1.5" stroke-linecap="round" fill="none"/>
            </svg>
          </div>
          <div class="gesture-arrow">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M5 12h14M13 6l6 6-6 6" stroke="rgba(255,255,255,0.3)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <div class="gesture-result-visual compact">
            <div class="particle-dots">
              <span style="top:30%;left:42%;opacity:0.9"></span>
              <span style="top:35%;left:50%;opacity:1;width:4px;height:4px"></span>
              <span style="top:28%;left:56%;opacity:0.8"></span>
              <span style="top:42%;left:44%;opacity:0.7"></span>
              <span style="top:45%;left:52%;opacity:0.9;width:4px;height:4px"></span>
              <span style="top:40%;left:60%;opacity:0.6"></span>
              <span style="top:50%;left:48%;opacity:0.8"></span>
              <span style="top:55%;left:54%;opacity:0.7"></span>
              <span style="top:38%;left:38%;opacity:0.5"></span>
              <span style="top:48%;left:58%;opacity:0.6"></span>
              <span style="top:33%;left:48%;opacity:0.8;width:3px;height:3px"></span>
              <span style="top:52%;left:42%;opacity:0.5"></span>
            </div>
          </div>
        </div>
        <div class="gesture-demo-info">
          <div class="gesture-demo-label">
            âœŠ Close Fist
            <span class="gesture-demo-tag">Form</span>
          </div>
          <div class="gesture-demo-desc">Particles gather and form the selected shape â€” move hand to steer</div>
        </div>
      </div>

      <!-- Open hand gesture -->
      <div class="gesture-demo-card">
        <div class="gesture-visual-flow">
          <div class="gesture-hand-visual">
            <svg viewBox="0 0 52 60" fill="none">
              <ellipse cx="26" cy="38" rx="12" ry="14" stroke="rgba(168,85,247,0.7)" stroke-width="1.5" fill="rgba(168,85,247,0.06)"/>
              <line x1="16" y1="28" x2="10" y2="10" stroke="rgba(168,85,247,0.8)" stroke-width="1.8" stroke-linecap="round"/>
              <line x1="21" y1="25" x2="18" y2="6" stroke="rgba(168,85,247,0.8)" stroke-width="1.8" stroke-linecap="round"/>
              <line x1="26" y1="24" x2="26" y2="4" stroke="rgba(168,85,247,0.8)" stroke-width="1.8" stroke-linecap="round"/>
              <line x1="31" y1="25" x2="34" y2="6" stroke="rgba(168,85,247,0.8)" stroke-width="1.8" stroke-linecap="round"/>
              <line x1="36" y1="28" x2="42" y2="12" stroke="rgba(168,85,247,0.8)" stroke-width="1.8" stroke-linecap="round"/>
              <circle cx="10" cy="9" r="2.5" fill="rgba(168,85,247,0.4)"/>
              <circle cx="18" cy="5" r="2.5" fill="rgba(168,85,247,0.4)"/>
              <circle cx="26" cy="3" r="2.5" fill="rgba(168,85,247,0.4)"/>
              <circle cx="34" cy="5" r="2.5" fill="rgba(168,85,247,0.4)"/>
              <circle cx="42" cy="11" r="2.5" fill="rgba(168,85,247,0.4)"/>
            </svg>
          </div>
          <div class="gesture-arrow">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M5 12h14M13 6l6 6-6 6" stroke="rgba(255,255,255,0.3)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <div class="gesture-result-visual dispersed">
            <div class="particle-dots">
              <span style="top:10%;left:15%;opacity:0.4"></span>
              <span style="top:18%;left:72%;opacity:0.5"></span>
              <span style="top:25%;left:35%;opacity:0.3"></span>
              <span style="top:55%;left:80%;opacity:0.4"></span>
              <span style="top:70%;left:20%;opacity:0.5"></span>
              <span style="top:80%;left:65%;opacity:0.3"></span>
              <span style="top:40%;left:10%;opacity:0.4"></span>
              <span style="top:62%;left:50%;opacity:0.35"></span>
              <span style="top:15%;left:50%;opacity:0.45"></span>
              <span style="top:75%;left:42%;opacity:0.3"></span>
              <span style="top:45%;left:68%;opacity:0.4"></span>
              <span style="top:85%;left:30%;opacity:0.35"></span>
            </div>
          </div>
        </div>
        <div class="gesture-demo-info">
          <div class="gesture-demo-label">
            ğŸ– Open Hand
            <span class="gesture-demo-tag">Release</span>
          </div>
          <div class="gesture-demo-desc">Particles scatter outward â€” move your hand around to steer them</div>
        </div>
      </div>
    </div>

    <button class="tutorial-btn" id="tutorial-dismiss">Start Experience âœ¦</button>
    <div class="tutorial-tip">ğŸ’¡ Drag to rotate the view &amp; use the side panel to change patterns</div>
  </div>
</div>
<div id="canvas-container">
  <canvas id="three-canvas"></canvas>
</div>

<!-- Side Panel -->
<div id="side-panel" class="glass">
  <div>
    <div class="panel-header">
      <div class="panel-logo">âœ¦</div>
      <div>
        <div class="panel-title">Stardust.el</div>
        <div class="panel-subtitle">Gesture Control</div>
      </div>
    </div>
  </div>

  <!-- Patterns -->
  <div class="section">
    <div class="section-label">Pattern</div>
    <div class="pattern-grid" id="pattern-grid">
      <button class="pattern-btn active" data-pattern="sphere">
        <span class="pattern-icon">â—‰</span>
        <span class="pattern-name">Sphere</span>
      </button>
      <button class="pattern-btn" data-pattern="galaxy">
        <span class="pattern-icon">ğŸŒ€</span>
        <span class="pattern-name">Galaxy</span>
      </button>
      <button class="pattern-btn" data-pattern="heart">
        <span class="pattern-icon">â™¥</span>
        <span class="pattern-name">Heart</span>
      </button>
      <button class="pattern-btn" data-pattern="special">
        <span class="pattern-icon">ğŸ’Œ</span>
        <span class="pattern-name">Special</span>
      </button>
      <button class="pattern-btn" data-pattern="cube">
        <span class="pattern-icon">â—‡</span>
        <span class="pattern-name">Cube</span>
      </button>
      <button class="pattern-btn" data-pattern="dna">
        <span class="pattern-icon">â§–</span>
        <span class="pattern-name">DNA Helix</span>
      </button>
      <button class="pattern-btn" data-pattern="torus">
        <span class="pattern-icon">â—</span>
        <span class="pattern-name">Torus</span>
      </button>
      <button class="pattern-btn" data-pattern="wave">
        <span class="pattern-icon">âˆ¿</span>
        <span class="pattern-name">Wave</span>
      </button>
      <button class="pattern-btn" data-pattern="star">
        <span class="pattern-icon">âœ¦</span>
        <span class="pattern-name">Star</span>
      </button>
    </div>
  </div>

  <!-- Colors -->
  <div class="section">
    <div class="section-label">Color</div>
    <div class="color-presets" id="color-presets">
      <div class="color-swatch active" data-color="#a855f7" style="background: #a855f7;"></div>
      <div class="color-swatch" data-color="#e879f9" style="background: #e879f9;"></div>
      <div class="color-swatch" data-color="#3b82f6" style="background: #3b82f6;"></div>
      <div class="color-swatch" data-color="#22d3ee" style="background: #22d3ee;"></div>
      <div class="color-swatch" data-color="#34d399" style="background: #34d399;"></div>
      <div class="color-swatch" data-color="#f43f5e" style="background: #f43f5e;"></div>
      <div class="color-swatch" data-color="#fb923c" style="background: #fb923c;"></div>
      <div class="color-swatch" data-color="#facc15" style="background: #facc15;"></div>
    </div>
    <div class="color-custom-row">
      <div class="color-input-wrap">
        <input type="color" id="color-picker" value="#a855f7">
      </div>
      <input type="text" class="color-hex" id="color-hex" value="#a855f7" maxlength="7">
    </div>
  </div>

  <!-- Particle Count -->
  <div class="section">
    <div class="section-label">Particle Count</div>
    <div class="slider-row">
      <input type="range" id="particle-slider" min="2000" max="30000" value="12000" step="1000">
      <span class="slider-value" id="particle-count-label">12K</span>
    </div>
  </div>

  <!-- Particle Size -->
  <div class="section">
    <div class="section-label">Particle Size</div>
    <div class="slider-row">
      <input type="range" id="size-slider" min="1" max="8" value="3" step="0.5">
      <span class="slider-value" id="size-label">3.0</span>
    </div>
  </div>

  <!-- Rotation Speed -->
  <div class="section">
    <div class="section-label">Rotation Speed</div>
    <div class="slider-row">
      <input type="range" id="rotation-slider" min="0" max="100" value="30">
      <span class="slider-value" id="rotation-label">30%</span>
    </div>
  </div>
</div>

<!-- Top Controls -->
<div id="top-controls">
  <button class="ctrl-btn" id="btn-toggle-panel" title="Toggle Panel">â˜°</button>
  <button class="ctrl-btn" id="btn-toggle-cam" title="Toggle Camera">ğŸ“·</button>
  <button class="ctrl-btn" id="btn-fullscreen" title="Fullscreen">â›¶</button>
</div>

<!-- Webcam Feed -->
<div id="webcam-container" class="glass" style="display:none;">
  <div class="webcam-header">
    <span class="webcam-label"><span class="webcam-status-dot"></span> HAND TRACK</span>
    <span class="webcam-gesture-label" id="gesture-label">â€”</span>
  </div>
  <div style="position:relative;">
    <video id="webcam-video" autoplay playsinline muted></video>
    <canvas id="hand-canvas"></canvas>
  </div>
</div>



<!-- Toast -->
<div id="info-toast" class="glass"></div>

<!-- Mobile Panel Toggle -->
<button id="mobile-panel-toggle">â˜° Settings</button>

<!-- Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const state = {
  pattern: 'sphere',
  color: new THREE.Color('#a855f7'),
  particleCount: 12000,
  particleSize: 3,
  rotationSpeed: 0.3,
  gestureOpenness: 0,        // 0 = closed fist, 1 = open hand
  targetOpenness: 0,
  handDetected: false,
  cameraActive: false,
  panelVisible: true,
  // Hand position tracking â€” palm center mapped to 3D offset
  handX: 0,           // current smoothed X
  handY: 0,           // current smoothed Y
  targetHandX: 0,     // target X from detection
  targetHandY: 0,     // target Y from detection
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  THREE.JS SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('three-canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0612, 0.035);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
camera.position.set(0, 0, 8);

// Ambient particles (background dust)
const dustGeo = new THREE.BufferGeometry();
const dustCount = 800;
const dustPos = new Float32Array(dustCount * 3);
for (let i = 0; i < dustCount * 3; i++) dustPos[i] = (Math.random() - 0.5) * 40;
dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
const dustMat = new THREE.PointsMaterial({ color: 0x4a3670, size: 0.03, transparent: true, opacity: 0.4 });
scene.add(new THREE.Points(dustGeo, dustMat));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PATTERN GENERATORS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function generatePattern(pattern, count) {
  const positions = new Float32Array(count * 3);
  switch (pattern) {
    case 'sphere':
      for (let i = 0; i < count; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 2.5 * Math.cbrt(Math.random());
        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);
      }
      break;
    case 'galaxy':
      for (let i = 0; i < count; i++) {
        const arm = Math.floor(Math.random() * 4);
        const dist = Math.random() * 3;
        const angle = dist * 2.5 + (arm * Math.PI / 2);
        const spread = 0.3 * (1 - dist / 3);
        positions[i * 3] = Math.cos(angle) * dist + (Math.random() - 0.5) * spread * 2;
        positions[i * 3 + 1] = (Math.random() - 0.5) * spread * 1.5;
        positions[i * 3 + 2] = Math.sin(angle) * dist + (Math.random() - 0.5) * spread * 2;
      }
      break;
    case 'heart':
      for (let i = 0; i < count; i++) {
        const t = Math.random() * Math.PI * 2;
        const s = Math.random() * Math.PI;
        const r = 2 * Math.cbrt(Math.random());
        let x = r * (16 * Math.pow(Math.sin(t), 3)) / 16;
        let y = r * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 16;
        let z = r * Math.sin(s) * 0.4 * Math.sin(t);
        positions[i * 3] = x;
        positions[i * 3 + 1] = y + 0.5;
        positions[i * 3 + 2] = z;
      }
      break;
    case 'cube':
      for (let i = 0; i < count; i++) {
        const face = Math.floor(Math.random() * 6);
        let x = Math.random() * 2 - 1;
        let y = Math.random() * 2 - 1;
        let z = Math.random() * 2 - 1;
        // Push to surface
        const surfaceChance = Math.random();
        if (surfaceChance > 0.3) {
          switch (face) {
            case 0: x = -1; break; case 1: x = 1; break;
            case 2: y = -1; break; case 3: y = 1; break;
            case 4: z = -1; break; case 5: z = 1; break;
          }
        }
        positions[i * 3] = x * 1.8;
        positions[i * 3 + 1] = y * 1.8;
        positions[i * 3 + 2] = z * 1.8;
      }
      break;
    case 'dna':
      for (let i = 0; i < count; i++) {
        const t = (i / count) * Math.PI * 6 - Math.PI * 3;
        const strand = Math.random() > 0.5 ? 1 : -1;
        const r = 1.2 + (Math.random() - 0.5) * 0.2;
        if (Math.random() > 0.7) {
          // Connection bars
          const barT = Math.floor(i / count * 30) / 30 * Math.PI * 6 - Math.PI * 3;
          const lerp = Math.random();
          positions[i * 3] = Math.cos(barT) * r * lerp + Math.cos(barT + Math.PI) * r * (1 - lerp);
          positions[i * 3 + 1] = barT * 0.4;
          positions[i * 3 + 2] = Math.sin(barT) * r * lerp + Math.sin(barT + Math.PI) * r * (1 - lerp);
        } else {
          const offset = strand > 0 ? 0 : Math.PI;
          positions[i * 3] = Math.cos(t + offset) * r;
          positions[i * 3 + 1] = t * 0.4;
          positions[i * 3 + 2] = Math.sin(t + offset) * r;
        }
      }
      break;
    case 'torus':
      for (let i = 0; i < count; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI * 2;
        const R = 2;
        const tubeR = 0.8 + (Math.random() - 0.5) * 0.3;
        positions[i * 3] = (R + tubeR * Math.cos(phi)) * Math.cos(theta);
        positions[i * 3 + 1] = tubeR * Math.sin(phi);
        positions[i * 3 + 2] = (R + tubeR * Math.cos(phi)) * Math.sin(theta);
      }
      break;
    case 'wave':
      for (let i = 0; i < count; i++) {
        const x = (Math.random() - 0.5) * 6;
        const z = (Math.random() - 0.5) * 6;
        const y = Math.sin(x * 1.5) * Math.cos(z * 1.5) * 1.2 + (Math.random() - 0.5) * 0.2;
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
      }
      break;
    case 'star':
      for (let i = 0; i < count; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const spikes = 5;
        const outerR = 2.5;
        const innerR = 1.2;
        const spikeAngle = theta * spikes / (Math.PI * 2);
        const blend = (Math.cos(spikeAngle * Math.PI * 2) + 1) / 2;
        const r = (innerR + (outerR - innerR) * blend) * Math.cbrt(Math.random());
        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);
      }
      break;
    case 'special':
      // Heart shape as base (fist closed)
      for (let i = 0; i < count; i++) {
        const t = Math.random() * Math.PI * 2;
        const s = Math.random() * Math.PI;
        const r = 2 * Math.cbrt(Math.random());
        let x = r * (16 * Math.pow(Math.sin(t), 3)) / 16;
        let y = r * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 16;
        let z = r * Math.sin(s) * 0.4 * Math.sin(t);
        positions[i * 3] = x;
        positions[i * 3 + 1] = y + 0.5;
        positions[i * 3 + 2] = z;
      }
      break;
  }
  return positions;
}

// Generate text particle positions using offscreen canvas
// Must ensure font is loaded before calling
let _fontLoaded = false;
async function ensureFontLoaded() {
  if (_fontLoaded) return;
  try {
    await document.fonts.load('bold 100px Pacifico');
    _fontLoaded = true;
  } catch(e) {
    console.warn('Font load failed, using fallback');
  }
}

function generateTextPositions(text, count) {
  const positions = new Float32Array(count * 3);
  const cvs = document.createElement('canvas');
  cvs.width = 1024;
  cvs.height = 300;
  const ctx = cvs.getContext('2d');
  
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, cvs.width, cvs.height);
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = 'bold 90px Pacifico, cursive';
  ctx.fillText(text, cvs.width / 2, cvs.height / 2);
  
  const imageData = ctx.getImageData(0, 0, cvs.width, cvs.height);
  const pixels = imageData.data;
  
  // Collect all lit pixel coords
  const litPixels = [];
  for (let y = 0; y < cvs.height; y += 2) {
    for (let x = 0; x < cvs.width; x += 2) {
      const idx = (y * cvs.width + x) * 4;
      if (pixels[idx] > 100) {
        litPixels.push({ x, y });
      }
    }
  }
  
  // Scale: map canvas coords to 3D space
  const scaleX = 10 / cvs.width;
  const scaleY = 5 / cvs.height;
  
  for (let i = 0; i < count; i++) {
    if (litPixels.length > 0) {
      const px = litPixels[Math.floor(Math.random() * litPixels.length)];
      positions[i * 3]     = (px.x - cvs.width / 2) * scaleX + (Math.random() - 0.5) * 0.05;
      positions[i * 3 + 1] = -(px.y - cvs.height / 2) * scaleY + (Math.random() - 0.5) * 0.05;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 0.3;
    } else {
      // Fallback sphere
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 2.5 * Math.cbrt(Math.random());
      positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = r * Math.cos(phi);
    }
  }
  
  return positions;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PARTICLE SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let particles, particleMaterial, particleGeometry;
let basePositions;
let dispersedPositions;

async function createParticles() {
  if (particles) {
    scene.remove(particles);
    particleGeometry.dispose();
    particleMaterial.dispose();
  }

  const count = state.particleCount;
  particleGeometry = new THREE.BufferGeometry();
  basePositions = generatePattern(state.pattern, count);
  
  // Generate dispersed positions
  dispersedPositions = new Float32Array(count * 3);
  
  if (state.pattern === 'special') {
    // Ensure cute font is loaded before rendering text
    await ensureFontLoaded();
    const textPos = generateTextPositions('I Love You', count);
    dispersedPositions.set(textPos);
  } else {
    // Default: random scatter
    for (let i = 0; i < count; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 5 + Math.random() * 8;
      dispersedPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      dispersedPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      dispersedPositions[i * 3 + 2] = r * Math.cos(phi);
    }
  }

  const positions = new Float32Array(count * 3);
  positions.set(basePositions);
  particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

  // Per-particle random for subtle animation
  const randoms = new Float32Array(count);
  for (let i = 0; i < count; i++) randoms[i] = Math.random();
  particleGeometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

  particleMaterial = new THREE.PointsMaterial({
    color: state.color,
    size: state.particleSize * 0.01,
    transparent: true,
    opacity: 0.85,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    sizeAttenuation: true,
  });

  particles = new THREE.Points(particleGeometry, particleMaterial);
  scene.add(particles);
}

createParticles();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ANIMATION LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const elapsed = clock.getElapsedTime();
  const dt = Math.min(clock.getDelta(), 0.05);

  // Smoothly interpolate gesture openness
  state.gestureOpenness += (state.targetOpenness - state.gestureOpenness) * 0.08;

  // Smoothly interpolate hand position
  state.handX += (state.targetHandX - state.handX) * 0.10;
  state.handY += (state.targetHandY - state.handY) * 0.10;

  if (particles) {
    // Update positions based on gesture
    const posAttr = particleGeometry.attributes.position;
    const arr = posAttr.array;
    const openness = state.gestureOpenness;

    // Rotate (slow down for special pattern when text visible)
    const rotMult = (state.pattern === 'special') ? (1 - openness * 0.9) : 1;
    particles.rotation.y += state.rotationSpeed * 0.005 * rotMult;
    particles.rotation.x = Math.sin(elapsed * 0.15) * 0.1 * rotMult;

    for (let i = 0; i < state.particleCount; i++) {
      const i3 = i * 3;
      // Lerp between base and dispersed
      arr[i3]     = basePositions[i3]     + (dispersedPositions[i3]     - basePositions[i3])     * openness;
      arr[i3 + 1] = basePositions[i3 + 1] + (dispersedPositions[i3 + 1] - basePositions[i3 + 1]) * openness;
      arr[i3 + 2] = basePositions[i3 + 2] + (dispersedPositions[i3 + 2] - basePositions[i3 + 2]) * openness;

      // Subtle floating
      const rand = particleGeometry.attributes.aRandom.array[i];
      arr[i3 + 1] += Math.sin(elapsed * 0.8 + rand * 10) * 0.02;
    }
    posAttr.needsUpdate = true;

    // Move entire particle group based on hand position (works for fist AND open)
    if (state.handDetected) {
      particles.position.x += (state.handX - particles.position.x) * 0.12;
      particles.position.y += (state.handY - particles.position.y) * 0.12;
    } else {
      // Drift back to center when no hand
      particles.position.x += (0 - particles.position.x) * 0.04;
      particles.position.y += (0 - particles.position.y) * 0.04;
    }

    // Scale based on gesture
    const scale = (state.pattern === 'special') ? 1.0 : 1.0 + openness * 0.3;
    particles.scale.setScalar(scale);

    // Opacity fades slightly when dispersed (except special pattern)
    if (state.pattern === 'special') {
      particleMaterial.opacity = 0.7 + openness * 0.2;
      particleMaterial.size = state.particleSize * 0.01 * (1 - openness * 0.3);
    } else {
      particleMaterial.opacity = 0.85 - openness * 0.3;
      particleMaterial.size = state.particleSize * 0.01 * (1 + openness * 0.5);
    }
  }

  renderer.render(scene, camera);
}
animate();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MEDIAPIPE HANDS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const videoEl = document.getElementById('webcam-video');
const handCanvas = document.getElementById('hand-canvas');
const handCtx = handCanvas.getContext('2d');

let mpHands = null;
let mpCamera = null;

async function initHandTracking() {
  mpHands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
  });

  mpHands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.5,
  });

  mpHands.onResults(onHandResults);

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: 'user' } });
    videoEl.srcObject = stream;

    mpCamera = new Camera(videoEl, {
      onFrame: async () => {
        if (mpHands) await mpHands.send({ image: videoEl });
      },
      width: 320,
      height: 240,
    });
    mpCamera.start();
    state.cameraActive = true;
    document.getElementById('webcam-container').style.display = '';
    document.getElementById('btn-toggle-cam').classList.add('active');
    showToast('Camera enabled â€” show your hand to control particles');
  } catch (err) {
    showToast('Camera access denied');
    console.error(err);
  }
}

function onHandResults(results) {
  // Draw hand landmarks
  handCanvas.width = handCanvas.clientWidth;
  handCanvas.height = handCanvas.clientHeight;
  handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);

  const container = document.getElementById('webcam-container');
  const gestureLabel = document.getElementById('gesture-label');

  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    const landmarks = results.multiHandLandmarks[0];
    container.classList.add('tracking');
    state.handDetected = true;

    // Draw connections
    handCtx.strokeStyle = 'rgba(168, 85, 247, 0.5)';
    handCtx.lineWidth = 1.5;
    const connections = [
      [0,1],[1,2],[2,3],[3,4],
      [0,5],[5,6],[6,7],[7,8],
      [5,9],[9,10],[10,11],[11,12],
      [9,13],[13,14],[14,15],[15,16],
      [13,17],[17,18],[18,19],[19,20],[0,17]
    ];
    connections.forEach(([a, b]) => {
      handCtx.beginPath();
      handCtx.moveTo(landmarks[a].x * handCanvas.width, landmarks[a].y * handCanvas.height);
      handCtx.lineTo(landmarks[b].x * handCanvas.width, landmarks[b].y * handCanvas.height);
      handCtx.stroke();
    });

    // Draw points
    landmarks.forEach((lm, idx) => {
      handCtx.beginPath();
      const sz = [4, 8, 12, 16, 20].includes(idx) ? 4 : 2.5;
      handCtx.arc(lm.x * handCanvas.width, lm.y * handCanvas.height, sz, 0, Math.PI * 2);
      handCtx.fillStyle = [4, 8, 12, 16, 20].includes(idx) ? '#a855f7' : 'rgba(255,255,255,0.7)';
      handCtx.fill();
    });

    // Calculate openness using finger curl detection (more accurate)
    const wrist = landmarks[0];
    const palmBase = landmarks[9]; // middle finger base
    
    // Calculate palm size for normalization
    const palmDx = palmBase.x - wrist.x;
    const palmDy = palmBase.y - wrist.y;
    const palmSize = Math.sqrt(palmDx * palmDx + palmDy * palmDy);
    
    if (palmSize < 0.01) { state.targetOpenness = 0; return; }
    
    // Check each finger: compare tip-to-wrist vs knuckle-to-wrist distance
    const fingers = [
      { tip: 8,  pip: 6 },   // index
      { tip: 12, pip: 10 },  // middle
      { tip: 16, pip: 14 },  // ring
      { tip: 20, pip: 18 },  // pinky
    ];
    
    let extendedCount = 0;
    fingers.forEach(f => {
      const tipDx = landmarks[f.tip].x - wrist.x;
      const tipDy = landmarks[f.tip].y - wrist.y;
      const tipDist = Math.sqrt(tipDx * tipDx + tipDy * tipDy);
      
      const pipDx = landmarks[f.pip].x - wrist.x;
      const pipDy = landmarks[f.pip].y - wrist.y;
      const pipDist = Math.sqrt(pipDx * pipDx + pipDy * pipDy);
      
      // Finger is extended if tip is further from wrist than PIP joint
      if (tipDist > pipDist * 1.05) extendedCount++;
    });
    
    // Thumb check separately (compare tip to IP joint distance from palm center)
    const thumbTipDx = landmarks[4].x - landmarks[2].x;
    const thumbTipDy = landmarks[4].y - landmarks[2].y;
    const thumbDist = Math.sqrt(thumbTipDx * thumbTipDx + thumbTipDy * thumbTipDy);
    if (thumbDist / palmSize > 0.6) extendedCount++;
    
    // Map 0-5 extended fingers to openness with dead zones
    let openness;
    if (extendedCount <= 1) {
      openness = 0;  // Fist - hard snap to 0
    } else if (extendedCount >= 4) {
      openness = 1;  // Full open
    } else {
      openness = (extendedCount - 1) / 3; // 2-3 fingers = partial
    }
    
    state.targetOpenness = openness;

    // â”€â”€ Hand position tracking â”€â”€
    const palmCenterX = (landmarks[0].x + landmarks[5].x + landmarks[9].x + landmarks[13].x + landmarks[17].x) / 5;
    const palmCenterY = (landmarks[0].y + landmarks[5].y + landmarks[9].y + landmarks[13].y + landmarks[17].y) / 5;
    const mappedX = -(palmCenterX - 0.5) * 8;
    const mappedY = -(palmCenterY - 0.5) * 6;
    state.targetHandX = mappedX;
    state.targetHandY = mappedY;

    // Update UI
    if (openness > 0.65) {
      gestureLabel.textContent = 'OPEN';
    } else if (openness < 0.3) {
      gestureLabel.textContent = 'FIST';
    } else {
      gestureLabel.textContent = 'HALF';
    }

  } else {
    container.classList.remove('tracking');
    state.handDetected = false;
    gestureLabel.textContent = 'â€”';
    state.targetOpenness = 0;
    state.targetHandX = 0;
    state.targetHandY = 0;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UI INTERACTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Pattern buttons
document.querySelectorAll('.pattern-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.pattern = btn.dataset.pattern;
    createParticles();
  });
});

// Color presets
document.querySelectorAll('.color-swatch').forEach(swatch => {
  swatch.addEventListener('click', () => {
    const c = swatch.dataset.color;
    setColor(c);
    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
    swatch.classList.add('active');
  });
});

function setColor(hex) {
  state.color.set(hex);
  if (particleMaterial) particleMaterial.color.set(hex);
  document.getElementById('color-picker').value = hex;
  document.getElementById('color-hex').value = hex;
}

document.getElementById('color-picker').addEventListener('input', (e) => {
  setColor(e.target.value);
  document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
});

document.getElementById('color-hex').addEventListener('change', (e) => {
  let v = e.target.value.trim();
  if (/^#[0-9a-fA-F]{6}$/.test(v)) {
    setColor(v);
    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
  }
});

// Sliders
document.getElementById('particle-slider').addEventListener('input', (e) => {
  state.particleCount = parseInt(e.target.value);
  document.getElementById('particle-count-label').textContent = (state.particleCount / 1000).toFixed(0) + 'K';
  createParticles();
});

document.getElementById('size-slider').addEventListener('input', (e) => {
  state.particleSize = parseFloat(e.target.value);
  document.getElementById('size-label').textContent = state.particleSize.toFixed(1);
  if (particleMaterial) particleMaterial.size = state.particleSize * 0.01;
});

document.getElementById('rotation-slider').addEventListener('input', (e) => {
  state.rotationSpeed = parseInt(e.target.value) / 100;
  document.getElementById('rotation-label').textContent = e.target.value + '%';
});

// Top controls
document.getElementById('btn-toggle-panel').addEventListener('click', () => {
  state.panelVisible = !state.panelVisible;
  document.getElementById('side-panel').classList.toggle('hidden', !state.panelVisible);
  document.getElementById('btn-toggle-panel').classList.toggle('active', state.panelVisible);
});

document.getElementById('btn-toggle-cam').addEventListener('click', () => {
  if (!state.cameraActive) {
    // If calibration was somehow skipped, init normally
    initHandTracking();
  } else {
    // Toggle webcam visibility
    const wc = document.getElementById('webcam-container');
    const visible = wc.style.display !== 'none';
    wc.style.display = visible ? 'none' : '';
  }
});

document.getElementById('btn-fullscreen').addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TOAST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showToast(msg) {
  const toast = document.getElementById('info-toast');
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 3000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RESIZE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DRAG TO ROTATE (Mouse + Touch)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let isDragging = false;
let prevPointerX = 0, prevPointerY = 0;
let orbitX = 0, orbitY = 0;
let targetOrbitX = 0, targetOrbitY = 0;
const orbitRadius = 8;

function onPointerDown(e) {
  // Don't capture drag on UI elements
  if (e.target.closest('#side-panel, #webcam-container, #top-controls, #calibration-overlay, #tutorial-popup, #mobile-panel-toggle, .ctrl-btn')) return;
  isDragging = true;
  const pt = e.touches ? e.touches[0] : e;
  prevPointerX = pt.clientX;
  prevPointerY = pt.clientY;
}

function onPointerMove(e) {
  if (!isDragging) return;
  const pt = e.touches ? e.touches[0] : e;
  const dx = pt.clientX - prevPointerX;
  const dy = pt.clientY - prevPointerY;
  targetOrbitX -= dx * 0.005;
  targetOrbitY += dy * 0.005;
  targetOrbitY = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetOrbitY));
  prevPointerX = pt.clientX;
  prevPointerY = pt.clientY;
}

function onPointerUp() {
  isDragging = false;
}

// Mouse events
document.addEventListener('mousedown', onPointerDown);
document.addEventListener('mousemove', onPointerMove);
document.addEventListener('mouseup', onPointerUp);

// Touch events
document.addEventListener('touchstart', onPointerDown, { passive: true });
document.addEventListener('touchmove', onPointerMove, { passive: true });
document.addEventListener('touchend', onPointerUp);

function updateCameraOrbit() {
  requestAnimationFrame(updateCameraOrbit);
  // Smooth interpolation
  orbitX += (targetOrbitX - orbitX) * 0.06;
  orbitY += (targetOrbitY - orbitY) * 0.06;
  
  camera.position.x = Math.sin(orbitX) * Math.cos(orbitY) * orbitRadius;
  camera.position.y = Math.sin(orbitY) * orbitRadius;
  camera.position.z = Math.cos(orbitX) * Math.cos(orbitY) * orbitRadius;
  camera.lookAt(0, 0, 0);
}
updateCameraOrbit();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CALIBRATION FLOW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let calibrationComplete = false;
let calibFistHoldTime = 0;
const CALIB_FIST_REQUIRED = 1.5; // seconds of holding fist
let calibMpHands = null;
let calibStream = null;

document.getElementById('btn-allow-cam').addEventListener('click', async () => {
  try {
    calibStream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: 'user' } });
    
    // Show calibration screen
    document.getElementById('cam-permission-screen').classList.add('hidden');
    document.getElementById('fist-calibration-screen').classList.add('active');
    
    // Set up calibration video
    const calibVideo = document.getElementById('calib-video');
    calibVideo.srcObject = calibStream;
    
    // Init mediapipe for calibration
    calibMpHands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
    });
    calibMpHands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.5,
    });
    calibMpHands.onResults(onCalibResults);
    
    const calibCam = new Camera(calibVideo, {
      onFrame: async () => {
        if (calibMpHands && !calibrationComplete) await calibMpHands.send({ image: calibVideo });
      },
      width: 320,
      height: 240,
    });
    calibCam.start();
    
  } catch (err) {
    console.error(err);
    document.querySelector('.cam-perm-desc').textContent = 'Camera access was denied. Please allow camera access and try again.';
    document.querySelector('.cam-perm-desc').style.color = '#f43f5e';
  }
});

let lastCalibTime = performance.now();

function onCalibResults(results) {
  if (calibrationComplete) return;
  
  const calibCanvas = document.getElementById('calib-hand-canvas');
  const calibCtx = calibCanvas.getContext('2d');
  calibCanvas.width = calibCanvas.clientWidth;
  calibCanvas.height = calibCanvas.clientHeight;
  calibCtx.clearRect(0, 0, calibCanvas.width, calibCanvas.height);
  
  const now = performance.now();
  const dt = (now - lastCalibTime) / 1000;
  lastCalibTime = now;
  
  const statusEl = document.getElementById('calib-status');
  const statusText = document.getElementById('calib-status-text');
  const fistGuide = document.getElementById('fist-guide');
  const ringFg = document.getElementById('calib-ring-fg');
  const circumference = 2 * Math.PI * 90; // r=90
  
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    const landmarks = results.multiHandLandmarks[0];
    
    // Draw landmarks on calib canvas
    calibCtx.strokeStyle = 'rgba(168, 85, 247, 0.5)';
    calibCtx.lineWidth = 1.5;
    const connections = [
      [0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
      [5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],
      [13,17],[17,18],[18,19],[19,20],[0,17]
    ];
    connections.forEach(([a, b]) => {
      calibCtx.beginPath();
      calibCtx.moveTo(landmarks[a].x * calibCanvas.width, landmarks[a].y * calibCanvas.height);
      calibCtx.lineTo(landmarks[b].x * calibCanvas.width, landmarks[b].y * calibCanvas.height);
      calibCtx.stroke();
    });
    landmarks.forEach((lm, idx) => {
      calibCtx.beginPath();
      const sz = [4, 8, 12, 16, 20].includes(idx) ? 4 : 2.5;
      calibCtx.arc(lm.x * calibCanvas.width, lm.y * calibCanvas.height, sz, 0, Math.PI * 2);
      calibCtx.fillStyle = [4, 8, 12, 16, 20].includes(idx) ? '#a855f7' : 'rgba(255,255,255,0.7)';
      calibCtx.fill();
    });
    
    // Check if fist
    const wrist = landmarks[0];
    const palmBase = landmarks[9];
    const palmDx = palmBase.x - wrist.x;
    const palmDy = palmBase.y - wrist.y;
    const palmSize = Math.sqrt(palmDx * palmDx + palmDy * palmDy);
    
    let isFist = false;
    if (palmSize > 0.01) {
      const fingers = [
        { tip: 8, pip: 6 }, { tip: 12, pip: 10 },
        { tip: 16, pip: 14 }, { tip: 20, pip: 18 },
      ];
      let extendedCount = 0;
      fingers.forEach(f => {
        const tipDx = landmarks[f.tip].x - wrist.x;
        const tipDy = landmarks[f.tip].y - wrist.y;
        const tipDist = Math.sqrt(tipDx * tipDx + tipDy * tipDy);
        const pipDx = landmarks[f.pip].x - wrist.x;
        const pipDy = landmarks[f.pip].y - wrist.y;
        const pipDist = Math.sqrt(pipDx * pipDx + pipDy * pipDy);
        if (tipDist > pipDist * 1.05) extendedCount++;
      });
      const thumbTipDx = landmarks[4].x - landmarks[2].x;
      const thumbTipDy = landmarks[4].y - landmarks[2].y;
      const thumbDist = Math.sqrt(thumbTipDx * thumbTipDx + thumbTipDy * thumbTipDy);
      if (thumbDist / palmSize > 0.6) extendedCount++;
      
      isFist = extendedCount <= 1;
    }
    
    fistGuide.classList.add('detected');
    
    if (isFist) {
      calibFistHoldTime += dt;
      statusEl.className = 'calib-status detecting';
      
      const progress = Math.min(calibFistHoldTime / CALIB_FIST_REQUIRED, 1);
      statusText.textContent = progress < 1 ? 'Hold your fist...' : 'Ready!';
      
      // Update ring progress
      const offset = circumference * (1 - progress);
      ringFg.style.strokeDashoffset = offset;
      
      if (progress >= 1) {
        statusEl.className = 'calib-status ready';
        statusText.textContent = 'Let\'s go! âœ¦';
        calibrationComplete = true;
        
        // Transition to main experience
        setTimeout(() => {
          finishCalibration();
        }, 500);
      }
    } else {
      // Reset if hand opens
      calibFistHoldTime = Math.max(0, calibFistHoldTime - dt * 2);
      statusEl.className = 'calib-status detecting';
      statusText.textContent = 'Close your hand into a fist';
      const progress = Math.min(calibFistHoldTime / CALIB_FIST_REQUIRED, 1);
      const offset = circumference * (1 - progress);
      ringFg.style.strokeDashoffset = offset;
    }
  } else {
    // No hand detected
    calibFistHoldTime = Math.max(0, calibFistHoldTime - dt * 3);
    fistGuide.classList.remove('detected');
    statusEl.className = 'calib-status';
    statusText.textContent = 'Waiting for hand...';
    const progress = Math.min(calibFistHoldTime / CALIB_FIST_REQUIRED, 1);
    const offset = circumference * (1 - progress);
    ringFg.style.strokeDashoffset = offset;
  }
}

async function finishCalibration() {
  // Hide calibration overlay
  document.getElementById('calibration-overlay').classList.add('hidden');
  
  // Show tutorial popup
  setTimeout(() => {
    document.getElementById('tutorial-popup').classList.add('visible');
  }, 400);
}

// Tutorial dismiss â€” now actually start the experience
document.getElementById('tutorial-dismiss').addEventListener('click', () => {
  document.getElementById('tutorial-popup').classList.remove('visible');
  document.body.classList.remove('calibrating');
  
  // Start hand tracking with calibration stream
  startMainHandTracking();
});

async function startMainHandTracking() {
  // Close calibration mediapipe
  if (calibMpHands) {
    calibMpHands.close();
    calibMpHands = null;
  }
  
  // Use the existing stream for the main hand tracking
  videoEl.srcObject = calibStream;
  
  mpHands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
  });
  mpHands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.5,
  });
  mpHands.onResults(onHandResults);
  
  mpCamera = new Camera(videoEl, {
    onFrame: async () => {
      if (mpHands) await mpHands.send({ image: videoEl });
    },
    width: 320,
    height: 240,
  });
  mpCamera.start();
  state.cameraActive = true;
  document.getElementById('webcam-container').style.display = '';
  document.getElementById('btn-toggle-cam').classList.add('active');
}

// Mobile panel toggle
document.getElementById('mobile-panel-toggle').addEventListener('click', () => {
  const panel = document.getElementById('side-panel');
  panel.classList.toggle('hidden');
  const btn = document.getElementById('mobile-panel-toggle');
  btn.textContent = panel.classList.contains('hidden') ? 'â˜° Settings' : 'âœ• Close';
});

// Start with panel hidden on mobile
if (window.innerWidth <= 768) {
  document.getElementById('side-panel').classList.add('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LOADING DONE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.addEventListener('load', () => {
  setTimeout(() => {
    document.getElementById('loading-overlay').classList.add('fade-out');
    setTimeout(() => document.getElementById('loading-overlay').style.display = 'none', 600);
  }, 500);
});
</script>
</body>
</html>
